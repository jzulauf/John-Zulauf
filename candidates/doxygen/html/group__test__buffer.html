<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Test buffer creation and management functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>Test buffer creation and management functions<br>
<small>
[<a class="el" href="group__test.html">"test_" Test framework for performance testing</a>]</small>
</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a0">test_buffer_get_align</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the next alignment value for the buffer. If alignment randomization is enabled, this will vary, otherwise it will be constant.</em> <a href="#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a1">test_buffer_toc_const</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, size_t count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Fills a toc for a given count and account for cacheline and align effects.</em> <a href="#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a2">test_buffer_toc_rand</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, size_t current_count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Fills a toc for a given count and account for cacheline and align effects.</em> <a href="#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a3">test_buffer_fill_from_toc</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Fill a buffer with based on the toc entries and the fill callback. Since both the _const and _rand toc initialization routines set all sample fields this can be used in either case.</em> <a href="#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a4">test_buffer_cb_fill_zstr</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, <a class="el" href="structT__test__sample.html">T_test_sample</a> *s, void *data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Standard callback to fill one sample with a zstring.</em> <a href="#a4"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a5">test_buffer_cb_fill_mem</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, <a class="el" href="structT__test__sample.html">T_test_sample</a> *s, void *data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Standard callback to fill one sample with a pattern (not NULL terminated).</em> <a href="#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a6">test_buffer_create</a> (size_t type, <a class="el" href="structT__test__app.html">T_test_app</a> *app, size_t scale, size_t extra_pad)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a single test buffer.</em> <a href="#a6"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a7">test_buffer_flush</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a8">test_buffer_count_change</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, size_t count, void *data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Default action to take on a buffer "count change" event, can be overriden by setting <a class="el" href="structT__test__buffer.html#m22">T_test_buffer::f_count</a>.</em> <a href="#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a9">test_buffer_wrap</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, size_t count, void *data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Default action to take on a buffer "wrap" event. Can be overridden by setting <a class="el" href="structT__test__buffer.html#m20">T_test_buffer::f_wrap</a>.</em> <a href="#a9"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structT__test__sample.html">T_test_sample</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a10">test_buffer_next</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, size_t count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the next sample from the buffer, handling the count change and buffer wrap cases.</em> <a href="#a10"></a><em></em></font><br><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a5" doxytag="test_utils.c::test_buffer_cb_fill_mem"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void test_buffer_cb_fill_mem </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>b</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structT__test__sample.html">T_test_sample</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Standard callback to fill one sample with a pattern (not NULL terminated).
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>b</em>&nbsp;</td><td>
the 'this' buffer the sample is in. </td></tr>
<tr><td valign=top><em>s</em>&nbsp;</td><td>
the sample to fill </td></tr>
<tr><td valign=top><em>data</em>&nbsp;</td><td>
private data for this callback (unused) </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a4" doxytag="test_utils.c::test_buffer_cb_fill_zstr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void test_buffer_cb_fill_zstr </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>b</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structT__test__sample.html">T_test_sample</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Standard callback to fill one sample with a zstring.
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>b</em>&nbsp;</td><td>
the 'this' buffer the sample is in. </td></tr>
<tr><td valign=top><em>s</em>&nbsp;</td><td>
the sample to fill </td></tr>
<tr><td valign=top><em>data</em>&nbsp;</td><td>
private data for this callback (unused) </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a8" doxytag="test_utils.c::test_buffer_count_change"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void test_buffer_count_change </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>b</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>count</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default action to take on a buffer "count change" event, can be overriden by setting <a class="el" href="structT__test__buffer.html#m22">T_test_buffer::f_count</a>.
<p>
Sets the toc for the current count if it has changed. Also responsible * for initialization (as count change happens in timetest(). Override this function by defining <a class="el" href="structT__test__buffer.html#m22">T_test_buffer::f_count</a> <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>b</em>&nbsp;</td><td>
the 'this' buffer to affect </td></tr>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
the current count </td></tr>
<tr><td valign=top><em>data</em>&nbsp;</td><td>
arbitrary private for the count change (ignored) </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a6" doxytag="test_utils.c::test_buffer_create"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structT__test__buffer.html">T_test_buffer</a>* test_buffer_create </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>type</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="structT__test__app.html">T_test_app</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>app</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>scale</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>extra_pad</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a single test buffer.
<p>
TODO: Needs a destructor <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>type</em>&nbsp;</td><td>
buffer type 0 for src, 1 for dst, &gt; 1 other (treated as dst) </td></tr>
<tr><td valign=top><em>app</em>&nbsp;</td><td>
the application state </td></tr>
<tr><td valign=top><em>scale</em>&nbsp;</td><td>
the multiplier for count to compute buffer sample size </td></tr>
<tr><td valign=top><em>extra_pad</em>&nbsp;</td><td>
the fixed amount to add to each buffer size </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
test buffer structure </dl>    </td>
  </tr>
</table>
<a name="a3" doxytag="test_utils.c::test_buffer_fill_from_toc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void test_buffer_fill_from_toc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>b</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fill a buffer with based on the toc entries and the fill callback. Since both the _const and _rand toc initialization routines set all sample fields this can be used in either case.
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>b</em>&nbsp;</td><td>
the 'this' buffer to affect </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a7" doxytag="test_utils.c::test_buffer_flush"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void test_buffer_flush </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>b</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Flush all the cachelines in the buffer <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>b</em>&nbsp;</td><td>
the 'this' buffer to affect </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a0" doxytag="test_utils.c::test_buffer_get_align"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> size_t test_buffer_get_align </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>b</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the next alignment value for the buffer. If alignment randomization is enabled, this will vary, otherwise it will be constant.
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>b</em>&nbsp;</td><td>
the 'this' buffer to affect </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
the appropriate alignment value </dl>    </td>
  </tr>
</table>
<a name="a10" doxytag="test_utils.c::test_buffer_next"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structT__test__sample.html">T_test_sample</a>* test_buffer_next </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>b</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>count</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the next sample from the buffer, handling the count change and buffer wrap cases.
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
the current count (ignored for rand) </td></tr>
<tr><td valign=top><em>b</em>&nbsp;</td><td>
the buffer to get the next sample from </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
pointer to the next sample in the the buffer </dl>    </td>
  </tr>
</table>
<a name="a1" doxytag="test_utils.c::test_buffer_toc_const"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void test_buffer_toc_const </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>b</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>count</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fills a toc for a given count and account for cacheline and align effects.
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>b</em>&nbsp;</td><td>
the 'this' buffer to affect </td></tr>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
the current constant for the toc </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="test_utils.c::test_buffer_toc_rand"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void test_buffer_toc_rand </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>b</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>current_count</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Fills a toc for a given count and account for cacheline and align effects.
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>b</em>&nbsp;</td><td>
the 'this' buffer to affect </td></tr>
<tr><td valign=top><em>current_count</em>&nbsp;</td><td>
the current constant count from the innerloop (e.g loop_innerloop() ) </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a9" doxytag="test_utils.c::test_buffer_wrap"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void test_buffer_wrap </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>b</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>count</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>data</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default action to take on a buffer "wrap" event. Can be overridden by setting <a class="el" href="structT__test__buffer.html#m20">T_test_buffer::f_wrap</a>.
<p>
Fills the toc with a new random distribution if app-&gt;rand. Note that if f_fill is NULL not actually fill anything. Override this function by defining <a class="el" href="structT__test__buffer.html#m20">T_test_buffer::f_wrap</a> <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>b</em>&nbsp;</td><td>
the 'this' buffer to affect </td></tr>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
the current count </td></tr>
<tr><td valign=top><em>data</em>&nbsp;</td><td>
arbitrary private for the wrap (ignored) </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr><address style="align: right;"><small>Generated on Thu Sep 14 15:20:11 2006 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
