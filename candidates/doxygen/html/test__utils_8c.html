<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>test_utils.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>/users/jcrouse/perforce/drivers/projects/geodelx/linux/glibc/candidates/common/utils/test_utils.c File Reference</h1>Implements a the test framework including application state and buffer managment. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;unistd.h&gt;</code><br>
<code>#include &lt;stdio.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;limits.h&gt;</code><br>
<code>#include "<a class="el" href="opts__utils_8h-source.html">opts_utils.h</a>"</code><br>
<code>#include "<a class="el" href="test__utils_8h-source.html">test_utils.h</a>"</code><br>
<code>#include "<a class="el" href="bucket__stats_8h-source.html">bucket_stats.h</a>"</code><br>
<code>#include "<a class="el" href="fake__lib_8h-source.html">fake_lib.h</a>"</code><br>
<code>#include "<a class="el" href="loop__test_8h-source.html">loop_test.h</a>"</code><br>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="a7" doxytag="test_utils.c::TEST_DEFAULT_START"></a>
#define&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a7">TEST_DEFAULT_START</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>default start count</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a8" doxytag="test_utils.c::TEST_DEFAULT_INCR"></a>
#define&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a8">TEST_DEFAULT_INCR</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>default count increment</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a9">TEST_DEFAULT_END</a>&nbsp;&nbsp;&nbsp;33</td></tr>
<tr><td nowrap align=right valign=top><a name="a10" doxytag="test_utils.c::TEST_DEFAULT_NUM_TRY"></a>
#define&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a10">TEST_DEFAULT_NUM_TRY</a>&nbsp;&nbsp;&nbsp;10000</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>default number of times to run each test for each count</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a11">TEST_APP_DATA_ULONG</a>(a, t, r, c, f)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a12">TEST_APP_DATA_ZSTR</a>(a, t, r, c, f)</td></tr>
<tr><td nowrap align=right valign=top><a name="a13" doxytag="test_utils.c::TEST_WARN"></a>
#define&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a13">TEST_WARN</a>(fmt, val)&nbsp;&nbsp;&nbsp;fprintf(stderr,"WARN: " fmt,val)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>print a warning to stderr</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a14">TEST_FATAL</a>(fmt, val)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>print an error msg to stderr</em> <a href="group__test__app.html#a14"></a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structT__test__app.html">T_test_app</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__test.html#a0">test_init</a> (const char *progname, const char *progversion, <a class="el" href="test__utils_8h.html#a53">T_test_type</a> type)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Initializes the app state structure and command line (opts table).</em> <a href="group__test.html#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test.html#a1">test_create_buffers</a> (<a class="el" href="structT__test__app.html">T_test_app</a> *app, size_t scale, size_t extra)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Allocates the default set of buffers <b>NOTE</b>: init buffers computes and allocates the buffers and the TOC but <b>doesn't</b> fill them. It <b>does</b> look at the <a class="el" href="structT__test__app.html">T_test_app</a> settings and the test_type to initialize the count and wrap call backs.</em> <a href="group__test.html#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__test.html#a2">test_action_oneshot</a> (void *ptr_to_test_app)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Callback for <a class="el" href="group__opts.html#a3">opts_getopt()</a> and the --oneshot flag.</em> <a href="group__test.html#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structT__test__app.html">T_test_app</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a0">test_app_create</a> (const char *name, const char *vers, <a class="el" href="test__utils_8h.html#a53">T_test_type</a> type)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Allocate the test application state structure and set the default values.</em> <a href="group__test__app.html#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>int&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a1">test_app_opts_cb_format</a> (void *data)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a2">test_app_default_opts</a> (<a class="el" href="structT__test__app.html">T_test_app</a> *app)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Add the common test commandline options to the opts table used by <a class="el" href="group__opts.html#a3">opts_getopt()</a>.</em> <a href="group__test__app.html#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a3">test_app_print_options</a> (<a class="el" href="structT__test__app.html">T_test_app</a> *app)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Outputs test option information.</em> <a href="group__test__app.html#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a4">test_app_fill_data</a> (<a class="el" href="structT__test__app.html">T_test_app</a> *app, <a class="el" href="table_8h.html#a9">T_table</a> *t, size_t row, size_t col)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a5">test_app_validate_options</a> (<a class="el" href="structT__test__app.html">T_test_app</a> *app)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Make sure the user inputs are "sane".</em> <a href="group__test__app.html#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structT__deck.html">T_deck</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__test__app.html#a6">test_app_count_deck_create</a> (<a class="el" href="structT__test__app.html">T_test_app</a> *app)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a deck to adjust count in buffer sequences. Card data stores a valid count value.</em> <a href="group__test__app.html#a6"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="group__test__comp.html#a0">test_compute_cl_stride</a> (size_t size, size_t align)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Compute a cacheline aligned stride given a size and an alignment.</em> <a href="group__test__comp.html#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="group__test__comp.html#a1">test_compute_buffer_size</a> (size_t min, size_t max)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>computes the buffer size from the strides and limits</em> <a href="group__test__comp.html#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>char *&nbsp;</td><td valign=bottom><a class="el" href="group__test__comp.html#a2">test_compute_next_cl</a> (char *addr)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>computes the next cacheline aligned address. If address is cacheline aligned, it is returned unaltered</em> <a href="group__test__comp.html#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__comp.html#a3">test_pat_fill</a> (char *buff, size_t n, const char *pat)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Fill a char buffer with a repeating pattern.</em> <a href="group__test__comp.html#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>size_t&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a0">test_buffer_get_align</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the next alignment value for the buffer. If alignment randomization is enabled, this will vary, otherwise it will be constant.</em> <a href="group__test__buffer.html#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a1">test_buffer_toc_const</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, size_t count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Fills a toc for a given count and account for cacheline and align effects.</em> <a href="group__test__buffer.html#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a2">test_buffer_toc_rand</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, size_t current_count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Fills a toc for a given count and account for cacheline and align effects.</em> <a href="group__test__buffer.html#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a3">test_buffer_fill_from_toc</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Fill a buffer with based on the toc entries and the fill callback. Since both the _const and _rand toc initialization routines set all sample fields this can be used in either case.</em> <a href="group__test__buffer.html#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a4">test_buffer_cb_fill_zstr</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, <a class="el" href="structT__test__sample.html">T_test_sample</a> *s, void *data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Standard callback to fill one sample with a zstring.</em> <a href="group__test__buffer.html#a4"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a5">test_buffer_cb_fill_mem</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, <a class="el" href="structT__test__sample.html">T_test_sample</a> *s, void *data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Standard callback to fill one sample with a pattern (not NULL terminated).</em> <a href="group__test__buffer.html#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structT__test__buffer.html">T_test_buffer</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a6">test_buffer_create</a> (size_t type, <a class="el" href="structT__test__app.html">T_test_app</a> *app, size_t scale, size_t extra_pad)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a single test buffer.</em> <a href="group__test__buffer.html#a6"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a7">test_buffer_flush</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a8">test_buffer_count_change</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, size_t count, void *data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Default action to take on a buffer "count change" event, can be overriden by setting <a class="el" href="structT__test__buffer.html#m22">T_test_buffer::f_count</a>.</em> <a href="group__test__buffer.html#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a9">test_buffer_wrap</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, size_t count, void *data)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Default action to take on a buffer "wrap" event. Can be overridden by setting <a class="el" href="structT__test__buffer.html#m20">T_test_buffer::f_wrap</a>.</em> <a href="group__test__buffer.html#a9"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="structT__test__sample.html">T_test_sample</a> *&nbsp;</td><td valign=bottom><a class="el" href="group__test__buffer.html#a10">test_buffer_next</a> (<a class="el" href="structT__test__buffer.html">T_test_buffer</a> *b, size_t count)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the next sample from the buffer, handling the count change and buffer wrap cases.</em> <a href="group__test__buffer.html#a10"></a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Implements a the test framework including application state and buffer managment.
<p>

<p>
<hr><address style="align: right;"><small>Generated on Thu Sep 14 15:20:11 2006 by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
